<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CallMe枪哥]]></title>
  <link href="http://beijingsn.github.io/atom.xml" rel="self"/>
  <link href="http://beijingsn.github.io/"/>
  <updated>2014-03-11T20:13:05+08:00</updated>
  <id>http://beijingsn.github.io/</id>
  <author>
    <name><![CDATA[Suning]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objc消息调用性能测试]]></title>
    <link href="http://beijingsn.github.io/blog/2014/03/11/xiao-xi-diao-yong-ce-shi/"/>
    <updated>2014-03-11T20:03:37+08:00</updated>
    <id>http://beijingsn.github.io/blog/2014/03/11/xiao-xi-diao-yong-ce-shi</id>
    <content type="html"><![CDATA[<p>测试了一下objc的消息调用性能，测试环境是2.3Gi7 16GDDR3</p>

<p>代码如下:</p>

<p>&hellip;&hellip;</p>

<p>clock_t start,end;
start = clock();
for (int i = 0; i &lt; 1000000; i++) {</p>

<pre><code>[ag testUid];
</code></pre>

<p>}
end = clock();
unsigned long k = (end-start);
NSLog(@&ldquo;first spend: %lu&rdquo;,k);</p>

<p>void (*simp)(id,SEL);</p>

<p>simp = (void(*)(id,SEL))[ag methodForSelector:@selector(testUid)];
start = clock();</p>

<p>for (int i = 0; i &lt; 1000000; i++) {</p>

<pre><code>simp(ag, @selector(testUid));
</code></pre>

<p>}
end = clock();</p>

<p>unsigned long j = (end &ndash; start);
NSLog(@&ldquo;second spend: %lu&rdquo;,j);
NSLog(@&ldquo;the per is %f%%&rdquo;,(float)(k-j)*100/k);</p>

<p>&hellip;&hellip;</p>

<p>测试结果:</p>

<p>2014-03-11 20:06:53.561 HelloWorld[9334:303] Hello, World!
2014-03-11 20:06:53.566 HelloWorld[9334:303] first spend: 3537
2014-03-11 20:06:53.569 HelloWorld[9334:303] second spend: 2081
2014-03-11 20:06:53.569 HelloWorld[9334:303] the per is 41.164829%</p>

<p>100万次的空消息调用，直接的函数调用比通过消息方式节约了大约33-42%
如果有密集型的循环调用，这里是可以优化一部分性能，但带来的负面是代码不易读。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objc消息调用性能测试]]></title>
    <link href="http://beijingsn.github.io/blog/2014/03/11/ce-shi/"/>
    <updated>2014-03-11T20:03:37+08:00</updated>
    <id>http://beijingsn.github.io/blog/2014/03/11/ce-shi</id>
    <content type="html"><![CDATA[<p>测试了一下objc的消息调用性能，测试环境是2.3Gi7 16GDDR3</p>

<p>代码如下:</p>

<p>&ndash;(void) test
{</p>

<pre><code>clock_t start,end;
start = clock();
for (int i = 0; i &lt; 1000000; i++) {
    [ag testUid];
}
end = clock();
unsigned long k = (end-start);
NSLog(@"first spend: %lu",k);

void (*simp)(id,SEL);

simp = (void(*)(id,SEL))[ag methodForSelector:@selector(testUid)];
start = clock();

for (int i = 0; i &lt; 1000000; i++) {
    simp(ag, @selector(testUid));
}
end = clock();


unsigned long j = (end - start);
NSLog(@"second spend: %lu",j);
NSLog(@"the per is %f%%",(float)(k-j)*100/k);
</code></pre>

<p>}</p>

<p>测试结果:</p>

<p>2014-03-11 20:06:53.561 HelloWorld[9334:303] Hello, World!\n
2014-03-11 20:06:53.566 HelloWorld[9334:303] first spend: 3537\n
2014-03-11 20:06:53.569 HelloWorld[9334:303] second spend: 2081\n
2014-03-11 20:06:53.569 HelloWorld[9334:303] the per is 41.164829%\n</p>

<p>100万次的空消息调用，直接的函数调用比通过消息方式节约了大约33-42%
如果有密集型的循环调用，这里是可以优化一部分性能，但带来的负面是代码不易读。</p>
]]></content>
  </entry>
  
</feed>
